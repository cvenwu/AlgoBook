# 第一个只出现一次的字符


## 方法一
思路：通过自定义的一个map来统计字符出现次数，两次遍历我们自定义map来获得最终结果。有一定的片面性，因为一个字符占8个字节，因此总共有256种可能，所以我们采用了一个长度为256的数组来自定义map。**将字符对应的ASCII码值作为map的键**

> *// 执行用时：8 ms, 在所有 Go 提交中击败了 82.52% 的用户*
>
> *// 内存消耗：5.9 MB, 在所有 Go 提交中击败了 7.32% 的用户*

```go
func firstUniqChar(s string) byte {
	if len(s) <= 0 {
		return ' ' // 如果没有找到返回一个单空格

	}

	bytes, mymap := []byte(s), [256]int{}
	for _, v := range bytes {
		mymap[v] += 1
	}
	for _, v := range bytes {
		if mymap[v] == 1 {
			return v  //找到返回对应的byte即可
		}
	}
	//说明没找到
	return ' ' // 如果没有找到返回一个单空格
}
```

## 【推荐】方法二：

**改进：使用一个长度为26的数组**

!> 时间复杂度：o(N)
!> 空间复杂度：因为使用的数组长度为26，大小是固定的，我们可以看作是O(1)

步骤：
1. 遍历题目中给的字符串，统计次数
2. 遍历题目中给的字符串，如果当前字符对应的长度为26数组的值为1，那么说明就是出现一次的字符
3. 否则就返回一个空格

```go
//因为s只包含小写英文字母，所以可以使用一个长度为26的数组来计算次数
//时间复杂度：O(N)
//空间复杂度：O(1) ，因为使用到了一个长度为26的数组
func firstUniqChar(s string) byte {
	hmap := [26]int{}

	//统计对应的次数
	for _, v := range s {
		hmap[v-97] += 1
	}

	//获取次数为1的小写英文字符并返回
	for _, v := range s {
		if hmap[v-'a'] == 1 {
			return byte(v)
		}
	}

	//说明没有找到只出现一次的，所以返回一个单空格
	return ' '
}
```


