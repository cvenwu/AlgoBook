# [448. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

## 方法一：暴力


暴力统计每个元素是否出现在数组中，
1. 时间复杂度：O(n^2) 
2. 空间复杂度：O(1)

## 方法二：使用哈希表

> 思路：使用map统计每个元素出现次数，之后遍历1-n将没有出现的数字加入结果中，
>

1. 时间复杂度：O(n) 

2. 空间复杂度：O(n)

## 方法三【推荐】：使用特殊方法进行标记，之后计数返回

**题目中规定时间复杂度O(N)且空间复杂度O(1)**
【参考别人的思路】：只能原地进行修改，因为题目中说明了1<=a[i]<=n，而索引优势0<=i<=n-1，我们可以对出现在原始数组中的数字进行标记，之后我们根据是否被标记判断数组的索引i对应的元素i+1是否存在。

步骤：（采用了一个策略，元素下标为0~n-1而数组元素值恰好为1~n，正好可以一一对应）

1. 遍历每个元素，假设当前元素对应的值为val
   1. 如果val大于0，找到下标为val-1的元素，如果该元素>0则将其变为负数，否则什么都不做
   2. 如果val小于0，则使用一个变量保存val*(-1)的结果，找到下标为val-1的元素，如果该元素>0则将其变为负数，否则什么都不做
2. 遍历完所有数组后，开始第2次遍历
   1. 如果当前元素为正数，说明对应的下标index应该对应的元素index+1没有出现在数组中，就加入结果中
   2. 如果为负数，就跳过

注意点：每次获取当前元素值，假设为val(这里我们每次都要获取绝对值，因为我们不能保证这个val是否被修改过
		//因为修改之后就为负数，索引的话就会报错),对应的索引val-1的值修改为负数(如果已经是负数就不用修改了)

**方法三的两个关键点：**

1. 需要原地进行修改  ----》 能否考虑到通过数组的值转换为索引(因为题目中说明了1<=a[i]<=n)
2. 对数组中出现的数字进行标记，如果被标记说明该下标i对应的元素i+1是否存在，否则将i+1加入到结果中

例如我们有一个元素值为4，那么我们让索引为3下标存储的数转换为-1或者-1*num[3]


> 执行用时：60 ms, 在所有 Go 提交中击败了82.28%的用户
> 		内存消耗：7.4 ms, 在所有 Go 提交中击败了14.11%的用户

```go
func findDisappearedNumbers(nums []int) []int {
	ret := []int{}
	for i := 0; i < len(nums); i++ {

		//注意：每次获取以当前元素值，假设为val(这里我们每次都要获取绝对值，因为我们不能保证这个val是否被修改过
		//因为修改之后就为负数，索引的话就会报错),对应的索引val-1的值修改为负数(如果已经是负数就不用修改了)
		index := nums[i]
		if index < 0 {
			index *= (-1)
		}
		if nums[index-1] > 0 {
			nums[index-1] *= (-1)
		}
	}

	//统计未被标记的并将其加入结果中
	for i, v := range nums {
		if v > 0 {
			ret = append(ret, i+1)
		}
	}

	return ret
}
```